SCRIPT  /home/mayank/.dotfile/nvim/.local/share/nvim/plugged/vim-misc/autoload/xolox/misc/option.vim
Sourced 1 time
Total time:   0.000176
 Self time:   0.000176

count  total (s)   self (s)
                            " Vim and plug-in option handling.
                            "
                            " Author: Peter Odding <peter@peterodding.com>
                            " Last Change: April 1, 2015
                            " URL: http://peterodding.com/code/vim/misc/
                            
    1              0.000008 function! xolox#misc#option#get(name, ...) " {{{1
                              " Expects one or two arguments: 1. The name of a variable and 2. the default
                              " value if the variable does not exist.
                              "
                              " Returns the value of the variable from a buffer local variable, global
                              " variable or the default value, depending on which is defined.
                              "
                              " This is used by some of my Vim plug-ins for option handling, so that users
                              " can customize options for specific buffers.
                              if exists('b:' . a:name)
                                " Buffer local variable.
                                return eval('b:' . a:name)
                              elseif exists('g:' . a:name)
                                " Global variable.
                                return eval('g:' . a:name)
                              elseif exists('a:1')
                                " Default value.
                                return a:1
                              endif
                            endfunction
                            
    1              0.000004 function! xolox#misc#option#split(value) " {{{1
                              " Given a multi-value Vim option like ['runtimepath'] [rtp] this returns a
                              " list of strings. For example:
                              "
                              "     :echo xolox#misc#option#split(&runtimepath)
                              "     ['/home/peter/Projects/Vim/misc',
                              "      '/home/peter/Projects/Vim/colorscheme-switcher',
                              "      '/home/peter/Projects/Vim/easytags',
                              "      ...]
                              "
                              " [rtp]: http://vimdoc.sourceforge.net/htmldoc/options.html#'runtimepath'
                              let values = split(a:value, '[^\\]\zs,')
                              return map(values, 's:unescape(v:val)')
                            endfunction
                            
    1              0.000005 function! s:unescape(s)
                              return substitute(a:s, '\\\([\\,]\)', '\1', 'g')
                            endfunction
                            
    1              0.000003 function! xolox#misc#option#join(values) " {{{1
                              " Given a list of strings like the ones returned by
                              " `xolox#misc#option#split()`, this joins the strings together into a
                              " single value that can be used to set a Vim option.
                              let values = copy(a:values)
                              call map(values, 's:escape(v:val)')
                              return join(values, ',')
                            endfunction
                            
    1              0.000003 function! s:escape(s)
                              return escape(a:s, ',\')
                            endfunction
                            
    1              0.000003 function! xolox#misc#option#split_tags(value) " {{{1
                              " Customized version of `xolox#misc#option#split()` with specialized
                              " handling for Vim's ['tags' option] [tags].
                              "
                              " [tags]: http://vimdoc.sourceforge.net/htmldoc/options.html#'tags'
                              let values = split(a:value, '[^\\]\zs,')
                              return map(values, 's:unescape_tags(v:val)')
                            endfunction
                            
    1              0.000003 function! s:unescape_tags(s)
                              return substitute(a:s, '\\\([\\, ]\)', '\1', 'g')
                            endfunction
                            
    1              0.000003 function! xolox#misc#option#join_tags(values) " {{{1
                              " Customized version of `xolox#misc#option#join()` with specialized
                              " handling for Vim's ['tags' option] [tags].
                              let values = copy(a:values)
                              call map(values, 's:escape_tags(v:val)')
                              return join(values, ',')
                            endfunction
                            
    1              0.000003 function! s:escape_tags(s)
                              return escape(a:s, ', ')
                            endfunction
                            
    1              0.000003 function! xolox#misc#option#eval_tags(value, ...) " {{{1
                              " Evaluate Vim's ['tags' option] [tags] without looking at the file
                              " system, i.e. this will report tags files that don't exist yet. Expects
                              " the value of the ['tags' option] [tags] as the first argument. If the
                              " optional second argument is 1 (true) only the first match is returned,
                              " otherwise (so by default) a list with all matches is returned.
                              let pathnames = []
                              let first_only = exists('a:1') ? a:1 : 0
                              for pattern in xolox#misc#option#split_tags(a:value)
                                " Make buffer relative pathnames absolute.
                                if pattern =~ '^\./'
                                  let suffix = matchstr(pattern, '^./\zs.*$')
                                  let directory = (&cpoptions =~# 'd') ? getcwd() : expand('%:p:h')
                                  let pattern = xolox#misc#path#merge(directory, suffix)
                                endif
                                " Make working directory relative pathnames absolute.
                                if xolox#misc#path#is_relative(pattern)
                                  let pattern = xolox#misc#path#merge(getcwd(), pattern)
                                endif
                                " Ignore the trailing `;' for recursive upwards searching because we
                                " always want the most specific pathname available.
                                let pattern = substitute(pattern, ';$', '', '')
                                " Expand the pattern.
                                call extend(pathnames, split(expand(pattern), "\n"))
                                if first_only && !empty(pathnames)
                                  return pathnames[0]
                                endif
                              endfor
                              return first_only ? '' : pathnames
                            endfunction
                            
                            " vim: ts=2 sw=2 et

FUNCTION  neomake#virtualtext#handle_current_error()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/neomake/autoload/neomake/virtualtext.vim line 78
Called 1 time
Total time:   0.000134
 Self time:   0.000073

count  total (s)   self (s)
                                    " Clean always.
    1              0.000004         if !empty(s:cur_virtualtext)
                                        if bufexists(s:cur_virtualtext[0])
                                            call nvim_buf_clear_highlight(s:cur_virtualtext[0], s:cur_virtualtext[1], 0, -1)
                                        endif
    1              0.000001         endif
    1              0.000005         if !get(g:, 'neomake_virtualtext_current_error', 1)
                                        return
    1              0.000001         endif
    1   0.000075   0.000014         let entry = neomake#get_nearest_error()
    1              0.000003         if empty(entry)
    1              0.000003             let s:cur_virtualtext = []
                                    else
                                        " Only add it when there is none already (stacking is not
                                        " supported).  https://github.com/neovim/neovim/issues/9285
                                        let buf_info = getbufvar(entry.bufnr, '_neomake_info', {})
                                        if index(get(buf_info, 'virtual_text_entries', []), entry.lnum) == -1
                                            let src_id = neomake#virtualtext#add_entry(entry, s:current_ns)
                                            let s:cur_virtualtext = [bufnr('%'), src_id]
                                        endif
    1              0.000001         endif

FUNCTION  <SNR>235_hl_group_exists()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/highlighter.vim line 95
Called 182 times
Total time:   0.002458
 Self time:   0.002458

count  total (s)   self (s)
  182              0.000639   if !hlexists(a:group)
                                return 0
  182              0.000962   elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
  182              0.000112   endif
  182              0.000181   return 1

FUNCTION  airline#extensions#undotree#apply()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/undotree.vim line 10
Called 2 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000005   if exists('t:undotree')
                                if &ft == 'undotree'
                                  if exists('*t:undotree.GetStatusLine')
                                    call airline#extensions#apply_left_override('undo', '%{exists("t:undotree") ? t:undotree.GetStatusLine() : ""}')
                                  else
                                    call airline#extensions#apply_left_override('undotree', '%f')
                                  endif
                                endif
                            
                                if &ft == 'diff' && exists('*t:diffpanel.GetStatusLine')
                                  call airline#extensions#apply_left_override('diff', '%{exists("t:diffpanel") ? t:diffpanel.GetStatusLine() : ""}')
                                endif
    2              0.000001   endif

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/util.vim line 76
Called 3 times
Total time:   0.002325
 Self time:   0.000262

count  total (s)   self (s)
   21              0.000024     for Fn in a:list
   20   0.002234   0.000170       let code = call(Fn, a:000)
   20              0.000019       if code != 0
    2              0.000002         return code
   18              0.000007       endif
   19              0.000012     endfor
    1              0.000001     return 0

FUNCTION  AirlineWebDevIcons()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-devicons/plugin/webdevicons.vim line 521
Called 2 times
Total time:   0.000107
 Self time:   0.000049

count  total (s)   self (s)
    2              0.000012   let w:airline_section_x = get(w:, 'airline_section_x', get(g:, 'airline_section_x', ''))
    2              0.000006   let w:airline_section_x .= ' %{WebDevIconsGetFileTypeSymbol()} '
    2   0.000075   0.000016   let hasFileFormatEncodingPart = airline#parts#ffenc() !=? ''
    2              0.000006   if g:webdevicons_enable_airline_statusline_fileformat_symbols && hasFileFormatEncodingPart
    2              0.000004     let w:airline_section_y = ' %{&fenc . " " . WebDevIconsGetFileFormatSymbol()} '
    2              0.000001   endif

FUNCTION  airline#extensions#neomake#get_warnings()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/neomake.vim line 21
Called 14 times
Total time:   0.000968
 Self time:   0.000263

count  total (s)   self (s)
   14   0.000860   0.000155   let counts = s:get_counts()
   14              0.000055   let warnings = get(counts, 'W', 0)
   14              0.000039   return warnings ? s:warning_symbol.warnings : ''

FUNCTION  bufferline#refresh_status()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-bufferline/plugin/bufferline.vim line 38
Called 14 times
Total time:   0.004286
 Self time:   0.000404

count  total (s)   self (s)
   14              0.000034   if g:bufferline_solo_highlight
                                if g:bufferline_status_info.count == 1
                                  exec printf('highlight! link %s %s', g:bufferline_active_highlight, g:bufferline_inactive_highlight)
                                else
                                  exec printf('highlight! link %s NONE', g:bufferline_active_highlight)
                                endif
   14              0.000009   endif
   14   0.004057   0.000176   call bufferline#get_echo_string()
   14              0.000017   return ''

FUNCTION  airline#extensions#tagbar#currenttag()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/tagbar.vim line 31
Called 14 times
Total time:   0.000572
 Self time:   0.000572

count  total (s)   self (s)
   14              0.000052   if get(w:, 'airline_active', 0)
   14              0.000025     if !s:init
                                  try
                                    " try to load the plugin, if filetypes are disabled,
                                    " this will cause an error, so try only once
                                    let a=tagbar#currenttag('%', '', '')
                                  catch
                                  endtry
                                  unlet! a
                                  let s:init=1
   14              0.000012     endif
                                " function tagbar#currenttag does not exist, if filetype is not enabled
   14              0.000106     if s:airline_tagbar_last_lookup_time != localtime() && exists("*tagbar#currenttag")
                                  let s:airline_tagbar_last_lookup_val = tagbar#currenttag('%s', '', s:flags)
                                  let s:airline_tagbar_last_lookup_time = localtime()
   14              0.000011     endif
   14              0.000035     return s:airline_tagbar_last_lookup_val
                              endif
                              return ''

FUNCTION  <SNR>214_parse_screen()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-css-color/autoload/css_color.vim line 220
Called 1 time
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
    1              0.000005 	let leftcol = winsaveview().leftcol
    1              0.000004 	let left = max([ leftcol - 15, 0 ])
    1              0.000002 	let width = &columns * 4
    1              0.000151 	call filter( range( line('w0'), line('w$') ), 'substitute( strpart( getline(v:val), col([v:val, left]), width ), b:css_color_pat, ''\=s:create_syn_match()'', ''g'' )' )

FUNCTION  airline#util#append()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/util.vim line 43
Called 98 times
Total time:   0.001371
 Self time:   0.001371

count  total (s)   self (s)
   98              0.000326   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
   98              0.000067   endif
   98              0.000409   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
   98              0.000386   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  airline#extensions#vimtex#apply()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/vimtex.vim line 43
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000005   if exists("b:vimtex")
                                let w:airline_section_x = get(w:, 'airline_section_x', g:airline_section_x)
                                let w:airline_section_x.=s:spc.g:airline_left_alt_sep.s:spc.'%{airline#extensions#vimtex#get_scope()}'
    2              0.000001   endif

FUNCTION  <SNR>235_exec_separator()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/highlighter.vim line 189
Called 42 times
Total time:   0.020607
 Self time:   0.001963

count  total (s)   self (s)
   42              0.000076   if pumvisible()
                                return
   42              0.000020   endif
   42              0.000141   let group = a:from.'_to_'.a:to.a:suffix
   42   0.005740   0.000376   let l:from = airline#themes#get_highlight(a:from.a:suffix)
   42   0.005353   0.000379   let l:to = airline#themes#get_highlight(a:to.a:suffix)
   42              0.000046   if a:inverse
   21              0.000084     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   21              0.000011   else
   21              0.000091     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   42              0.000021   endif
   42              0.000123   let a:dict[group] = colors
   42   0.008704   0.000399   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>226_check_mixed_indent()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 15
Called 1 time
Total time:   0.000250
 Self time:   0.000250

count  total (s)   self (s)
    1              0.000007   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    1              0.000002   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
    1              0.000003   elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
    1              0.000001   else
    1              0.000220     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/themes.vim line 31
Called 84 times
Total time:   0.010338
 Self time:   0.000943

count  total (s)   self (s)
   84   0.010309   0.000914   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  airline#mode_changed()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline.vim line 279
Called 5 times
Total time:   0.000170
 Self time:   0.000126

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    5              0.000062   let g:airline#visual_active = (mode() =~? '[vs]')
    5   0.000094   0.000050   call airline#update_tabline()

FUNCTION  <SNR>241_AutoReloadStatus()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-fugitive/autoload/fugitive.vim line 2078
Called 1 time
Total time:   0.000289
 Self time:   0.000034

count  total (s)   self (s)
    1   0.000037   0.000015   if s:CanAutoReloadStatus()
    1   0.000250   0.000018     return call('fugitive#ReloadStatus', a:000)
                              endif

FUNCTION  xolox#session#locking_enabled()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-session/autoload/xolox/session.vim line 1049
Called 1 time
Total time:   0.001076
 Self time:   0.000773

count  total (s)   self (s)
                              " Check whether session locking is enabled. Returns true (1) when locking is
                              " enabled, false (0) otherwise.
                              "
                              " By default session locking is enabled but users can opt-out by setting
                              " `g:session_lock_enabled` to false (0).
    1   0.001071   0.000769   return xolox#misc#option#get('session_lock_enabled', 1)

FUNCTION  neomake#GetCurrentErrorMsg()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/neomake/autoload/neomake.vim line 2466
Called 1 time
Total time:   0.000099
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000093   0.000017     let entry = neomake#get_nearest_error()
    1              0.000003     if empty(entry)
    1              0.000002         return ''
                                endif
                                let r = entry.maker_name . ': ' . entry.text
                                let suffix = entry.type . (entry.nr != -1 ? entry.nr : '')
                                if !empty(suffix)
                                    let r .= ' ('.suffix.')'
                                endif
                                return r

FUNCTION  DisableRelativeNumber()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-line-number-fold/plugin/number.vim line 21
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000014 	set number
    1              0.000005 	set norelativenumber

FUNCTION  <SNR>239_add_section()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/default.vim line 47
Called 14 times
Total time:   0.001102
 Self time:   0.000396

count  total (s)   self (s)
   14              0.000056     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   14   0.000167   0.000065     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
   14              0.000006     endif
   14              0.000011     if condition
                                  call a:builder.add_raw('%(')
   14              0.000005     endif
   14   0.000766   0.000163     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   14              0.000012     if condition
                                  call a:builder.add_raw('%)')
   14              0.000006     endif

FUNCTION  <SNR>238_get_transitioned_seperator()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/builder.vim line 143
Called 12 times
Total time:   0.006186
 Self time:   0.000406

count  total (s)   self (s)
   12              0.000015   let line = ''
   12              0.000047   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
   12              0.000006   else
   12   0.005892   0.000113     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   12              0.000050     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   12              0.000044     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   12              0.000024     let line .= '%#'.a:group.'#'
   12              0.000006   endif
   12              0.000012   return line

FUNCTION  airline#parts#filetype()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/parts.vim line 102
Called 14 times
Total time:   0.000435
 Self time:   0.000245

count  total (s)   self (s)
   14   0.000424   0.000234   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? 'â€¦' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/netrw.vim line 10
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000008   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
    2              0.000001   endif

FUNCTION  airline#parts#iminsert()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/parts.vim line 82
Called 14 times
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
   14              0.000054   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
   14              0.000010   endif
   14              0.000016   return ''

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/term.vim line 6
Called 2 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    2              0.000009   if &buftype == 'terminal' || bufname('%')[0] == '!'
                                let spc = g:airline_symbols.space
                            
                                let name=get(g:airline_mode_map, 't', 't')
                                call a:1.add_section('airline_a', spc.name.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_term', spc.s:termname())
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
    2              0.000001   endif

FUNCTION  <SNR>235_CheckDefined()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/highlighter.vim line 132
Called 182 times
Total time:   0.005351
 Self time:   0.005351

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  182              0.000773   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  182              0.000117   endif
  182              0.000810   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
  182              0.000106   endif
                            
  182              0.000575   for val in a:colors
  182              0.000603     if !empty(val) && val !=# 'NONE'
  182              0.000289       return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>226_conflict_marker()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 50
Called 1 time
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
                              " Checks for git conflict markers
    1              0.000003   let annotation = '\%([0-9A-Za-z_.:]\+\)\?'
    1              0.000008   let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(=\{7\}\)\|\%(>\{7\} '.annotation.'\)\)$'
    1              0.000075   return search(pattern, 'nw')

FUNCTION  300()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/builder.vim line 8
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000007   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  302()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/builder.vim line 17
Called 14 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
   14              0.000045   call add(self._sections, [a:group, a:contents])

FUNCTION  <SNR>226_check_mixed_indent_file()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 32
Called 1 time
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
    1              0.000011   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    1              0.000010   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
    1              0.000001   else
    1              0.000003     let head_spc = '\v(^ +)'
    1              0.000001   endif
    1              0.000015   let indent_tabs = search('\v(^\t+)', 'nw')
    1              0.000018   let indent_spc  = search(head_spc, 'nw')
    1              0.000003   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
    1              0.000001   else
    1              0.000001     return ''
                              endif

FUNCTION  bufferline#get_echo_string()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-bufferline/autoload/bufferline.vim line 61
Called 15 times
Total time:   0.004257
 Self time:   0.001110

count  total (s)   self (s)
                              " check for special cases like help files
   15              0.000069   let current = bufnr('%')
   15              0.000073   if !bufexists(current) || !buflisted(current)
                                return bufname('%')
   15              0.000010   endif
                            
   15   0.003334   0.000187   let names = s:generate_names()
   15              0.000028   let line = ''
   30              0.000062   for val in names
   15              0.000058     let line .= val[1]
   30              0.000034   endfor
                            
   15              0.000194   let index = match(line, '\V'.g:bufferline_status_info.current)
   15              0.000062   let g:bufferline_status_info.count = len(names)
   15              0.000081   let g:bufferline_status_info.before = strpart(line, 0, index)
   15              0.000099   let g:bufferline_status_info.after = strpart(line, index + len(g:bufferline_status_info.current))
   15              0.000024   return line

FUNCTION  <SNR>89_log()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/neomake/autoload/neomake/log.vim line 30
Called 1 time
Total time:   0.000041
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000006     let context = a:0 ? a:1 : {}
    1   0.000024   0.000010     let verbosity = neomake#utils#get_verbosity(context)
    1              0.000003     let logfile = get(g:, 'neomake_logfile', '')
                            
    1              0.000004     if !s:is_testing && verbosity < a:level && empty(logfile)
    1              0.000001         return
                                endif
                            
                                if a:0
                                    if has_key(a:1, 'options')
                                        let context = copy(a:1.options)
                                        let context.make_id = a:1.make_id
                                    else
                                        let context = copy(a:1)
                                    endif
                                    let msg = printf('[%s.%s:%s:%d] %s', get(context, 'make_id', '-'), get(context, 'id', '-'), get(context, 'bufnr', get(context, 'file_mode', 0) ? '?' : '-'), get(context, 'winnr', winnr()), a:msg)
                                else
                                    let msg = a:msg
                                endif
                            
                                " Use Vader's log for messages during tests.
                                " @vimlint(EVL104, 1, l:timediff)
                                if s:is_testing && (verbosity >= a:level || get(g:, 'neomake_test_log_all_messages', 0))
                                    let timediff = s:reltime_lastmsg()
                                    if timediff !=# '     '
                                        let test_msg = '['.s:short_level_to_name[a:level].' '.timediff.']: '.msg
                                    else
                                        let test_msg = '['.s:level_to_name[a:level].']: '.msg
                                    endif
                            
                                    if exists('*vader#log')
                                        " Might not exist with rpcrequest-based nvim test, or throw errors
                                        " if called too early.
                                        call vader#log(test_msg)
                                    endif
                                    " Only keep context entries that are relevant for / used in the message.
                                    let context = a:0 ? extend(filter(copy(context), "index(['id', 'make_id', 'bufnr', 'winnr'], v:key) != -1"), {'winnr': winnr()}, 'keep') : {}
                                    call add(g:neomake_test_messages, [a:level, a:msg, context])
                                    if index(['.', '!', ')', ']'], a:msg[-1:-1]) == -1
                                        let g:neomake_test_errors += ['Log msg does not end with punctuation: "'.a:msg.'".']
                                    endif
                                elseif verbosity >= a:level
                                    redraw
                                    if verbosity > 2
                                        echom 'Neomake: '.msg
                                    else
                                        if a:level ==# 0
                                            echohl ErrorMsg
                                        else
                                            echohl WarningMsg
                                        endif
                                        " Use message without context for non-debug msgs.
                                        echom 'Neomake: '.a:msg
                                        echohl None
                                    endif
                                endif
                                if !empty(logfile)
                                    if !exists('s:logfile_writefile_opts')
                                        " Use 'append' with writefile, but only if it is available.  Otherwise, just
                                        " overwrite the file.  'S' is used to disable fsync in Neovim
                                        " (https://github.com/neovim/neovim/pull/6427).
                                        if has('patch-7.4.503')
                                            let s:logfile_writefile_opts = 'aS'
                                        else
                                            let s:logfile_writefile_opts = ''
                                            redraw
                                            echohl WarningMsg
                                            echom 'Neomake: appending to the logfile is not supported in your Vim version.'
                                            echohl NONE
                                        endif
                                    endif
                            
                                    let time = strftime('%H:%M:%S')
                                    if !exists('timediff')
                                        let timediff = s:reltime_lastmsg()
                                    endif
                                    try
                                        call writefile([printf('%s %s [%s %s] %s', time, s:pid, s:short_level_to_name[a:level], timediff, msg)], logfile, s:logfile_writefile_opts)
                                    catch
                                        unlet g:neomake_logfile
                                        call neomake#log#error(printf('Error when trying to write to logfile %s: %s.  Unsetting g:neomake_logfile.', logfile, v:exception))
                                    endtry
                                endif
                                " @vimlint(EVL104, 0, l:timediff)

FUNCTION  xolox#session#auto_save()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-session/autoload/xolox/session.vim line 443
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
                              " Automatically save the current editing session when Vim is closed.
                              " Normally called by the [VimLeavePre] [] automatic command event.
                              "
                              " [VimLeavePre]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimLeavePre
    1              0.000003   if v:dying
                                " We won't save the session if Vim is not terminating normally.
                                return
    1              0.000001   endif
    1              0.000004   if g:session_autosave == 'no'
                                " We won't save the session if auto-save is explicitly disabled.
    1              0.000001     return
                              endif
                              " Get the name of the session for automatic saving.
                              let name = xolox#misc#option#get('session_autosave_to')
                              if empty(name)
                                " Get the name of the active session (if any).
                                let name = xolox#session#find_current_session()
                                " If no session is active and the user doesn't have any sessions yet,
                                " help them get started by suggesting to create the default session.
                                if empty(name) && (empty(xolox#session#get_names(0)) || g:session_default_overwrite)
                                  let name = g:session_default_name
                                endif
                              endif
                              " Prompt the user to save the active/first/default session?
                              if !empty(name)
                                let is_tab_scoped = xolox#session#is_tab_scoped()
                                let msg = "Do you want to save your %s before quitting Vim?"
                                if s:prompt(printf(msg, xolox#session#get_label(name, is_tab_scoped)), ["&Save", "&Don't Save"], 'g:session_autosave') == 1
                                  if g:session_default_overwrite && (name == g:session_default_name)
                                    let bang = '!'
                                  else
                                    let bang = ''
                                  endif
                                  if is_tab_scoped
                                    call xolox#session#save_tab_cmd(name, bang, 'SaveTabSession')
                                  else
                                    call xolox#session#save_cmd(name, bang, 'SaveSession')
                                  endif
                                endif
                              endif

FUNCTION  <SNR>235_get_syn()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/highlighter.vim line 37
Called 572 times
Total time:   0.017040
 Self time:   0.017040

count  total (s)   self (s)
  572              0.001789   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
  572              0.000324   endif
  572              0.000793   let color = ''
  572              0.001485   if hlexists(a:group)
  572              0.003463     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
  572              0.000355   endif
  572              0.001493   if empty(color) || color == -1
                                " should always exists
                                let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
                                if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
  572              0.000300   endif
  572              0.000684   return color

FUNCTION  <SNR>135_generate_names()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-bufferline/autoload/bufferline.vim line 7
Called 15 times
Total time:   0.003147
 Self time:   0.003147

count  total (s)   self (s)
   15              0.000036   let names = []
   15              0.000027   let i = 1
   15              0.000054   let last_buffer = bufnr('$')
   15              0.000045   let current_buffer = bufnr('%')
   30              0.000085   while i <= last_buffer
   15              0.000065     if bufexists(i) && buflisted(i)
   15              0.000033       let modified = ' '
   15              0.000122       if getbufvar(i, '&mod')
                                    let modified = g:bufferline_modified
   15              0.000013       endif
   15              0.000107       let fname = fnamemodify(bufname(i), g:bufferline_fname_mod)
   15              0.000035       if g:bufferline_pathshorten != 0
                                    let fname = pathshorten(fname)
   15              0.000010       endif
   15              0.000146       let fname = substitute(fname, "%", "%%", "g")
                            
   15              0.000031       let skip = 0
   30              0.000078       for ex in g:bufferline_excludes
   15              0.000127         if match(fname, ex) > -1
                                      let skip = 1
                                      break
   15              0.000010         endif
   30              0.000037       endfor
                            
   15              0.000033       if !skip
   15              0.000031         let name = ''
   15              0.000081         if g:bufferline_show_bufnr != 0 && g:bufferline_status_info.count >= g:bufferline_show_bufnr
   15              0.000049           let name =  i . ':'
   15              0.000012         endif
   15              0.000064         let name .= fname . modified
                            
   15              0.000033         if current_buffer == i
   15              0.000085           let name = g:bufferline_active_buffer_left . name . g:bufferline_active_buffer_right
   15              0.000060           let g:bufferline_status_info.current = name
                                    else
                                      let name = g:bufferline_separator . name . g:bufferline_separator
   15              0.000010         endif
                            
   15              0.000093         call add(names, [i, name])
   15              0.000011       endif
   15              0.000009     endif
   15              0.000035     let i += 1
   30              0.000062   endwhile
                            
   15              0.000045   if len(names) > 1
                                if g:bufferline_rotate == 1
                                  call bufferline#algos#fixed_position#modify(names)
                                endif
   15              0.000011   endif
                            
   15              0.000026   return names

FUNCTION  airline#util#winwidth()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/util.vim line 13
Called 54 times
Total time:   0.000691
 Self time:   0.000691

count  total (s)   self (s)
   54              0.000220   let nr = get(a:000, 0, 0)
   54              0.000158   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
   54              0.000042   else
   54              0.000141     return winwidth(nr)
                              endif

FUNCTION  307()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/builder.vim line 62
Called 2 times
Total time:   0.011217
 Self time:   0.001466

count  total (s)   self (s)
    2              0.000003   let side = 1
    2              0.000002   let line = ''
    2              0.000002   let i = 0
    2              0.000005   let length = len(self._sections)
    2              0.000002   let split = 0
    2              0.000002   let is_empty = 0
    2              0.000003   let prev_group = ''
                            
   18              0.000026   while i < length
   16              0.000035     let section = self._sections[i]
   16              0.000026     let group = section[0]
   16              0.000027     let contents = section[1]
   16              0.000021     let pgroup = prev_group
   16   0.000323   0.000155     let prev_group = airline#builder#get_prev_group(self._sections, i)
   16              0.000039     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
   16              0.000048     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
   16              0.000042     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
   16              0.000007     endif
   16              0.000013     if is_empty
                                  let prev_group = pgroup
   16              0.000006     endif
   16   0.000322   0.000126     let is_empty = s:section_is_empty(self, contents)
                            
   16              0.000012     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
   16              0.000006     endif
                            
   16              0.000018     if group == ''
                                  let line .= contents
   16              0.000016     elseif group == '|'
    2              0.000002       let side = 0
    2              0.000004       let line .= contents
    2              0.000002       let split = 1
   14              0.000007     else
   14              0.000015       if prev_group == ''
    2              0.000006         let line .= '%#'.group.'#'
   12              0.000010       elseif split
    2              0.000002         if !is_empty
    2   0.001127   0.000021           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    2              0.000001         endif
    2              0.000002         let split = 0
   10              0.000005       else
   10              0.000008         if !is_empty
   10   0.007750   0.000098           let line .= s:get_seperator(self, prev_group, group, side)
   10              0.000006         endif
   14              0.000006       endif
   14   0.000812   0.000181       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   16              0.000007     endif
                            
   16              0.000024     let i = i + 1
   18              0.000015   endwhile
                            
    2              0.000003   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    2              0.000001   endif
    2              0.000005   return line

FUNCTION  xolox#misc#msg#debug()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-misc/autoload/xolox/misc/msg.vim line 48
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                              " Show a formatted debugging message to the user, *if the user has enabled
                              " increased verbosity by setting Vim's ['verbose'] [] option to one
                              " (1) or higher*.
                              "
                              " This function has the same argument handling as the
                              " `xolox#misc#msg#info()` function.
                              "
                              " In the case of `xolox#misc#msg#debug()`, automatic string coercion
                              " provides lazy evaluation in the sense that complex data structures are
                              " only converted to strings when the user has enabled increased verbosity.
                              "
                              " ['verbose']: http://vimdoc.sourceforge.net/htmldoc/options.html#'verbose'
    2              0.000007   if &vbs >= 1
                                call s:show_message('Question', a:000)
    2              0.000002   endif

FUNCTION  airline#extensions#apply()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions.vim line 63
Called 2 times
Total time:   0.000203
 Self time:   0.000115

count  total (s)   self (s)
    2              0.000008   let filetype_overrides = get(s:, 'filetype_overrides', {})
    2              0.000012   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
    2   0.000103   0.000015   if s:is_excluded_window()
                                return -1
    2              0.000001   endif
                            
    2              0.000004   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
    2              0.000001   endif
                            
    2              0.000002   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
    2              0.000001   endif
                            
    2              0.000014   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
                                let args = filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
    2              0.000001   endif
                            
    2              0.000003   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
    2              0.000001   endif
                            
    2              0.000006   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
    2              0.000001   endfor

FUNCTION  <SNR>226_ws_refresh()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 178
Called 1 time
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    1              0.000008   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
                                return
    1              0.000001   endif
    1              0.000005   unlet! b:airline_whitespace_check
    1              0.000005   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
    1              0.000001   endif
    1              0.000004   let b:airline_ws_changedtick = b:changedtick

FUNCTION  UpdateNumberByFocus()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-line-number-fold/plugin/number.vim line 49
Called 2 times
Total time:   0.000236
 Self time:   0.000072

count  total (s)   self (s)
    2              0.000015 	if (a:curr_focus==0)
    1   0.000078   0.000017 		call UpdateNumberByMode(1)
    1              0.000003 	else
                            		" When focus is gained: It is always a Normal mode
    1   0.000122   0.000019 		call UpdateNumberByMode(0)
    2              0.000002 	endif

FUNCTION  <SNR>130_CursorHoldUpdate()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 263
Called 1 time
Total time:   0.000113
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000012     if g:NERDTreeUpdateOnCursorHold != 1
                                    return
    1              0.000002     endif
                            
    1   0.000089   0.000020     if !g:NERDTree.IsOpen()
    1              0.000002         return
                                endif
                            
                                " Do not update when a special buffer is selected
                                if !empty(&l:buftype)
                                    return
                                endif
                            
                                let l:winnr = winnr()
                                let l:altwinnr = winnr('#')
                            
                                call g:NERDTree.CursorToTreeWin()
                                call b:NERDTree.root.refreshFlags()
                                call NERDTreeRender()
                            
                                exec l:altwinnr . 'wincmd w'
                                exec l:winnr . 'wincmd w'

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/default.vim line 79
Called 2 times
Total time:   0.001533
 Self time:   0.000124

count  total (s)   self (s)
    2              0.000005   let winnr = a:context.winnr
    2              0.000003   let active = a:context.active
                            
    2   0.000024   0.000016   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    2   0.000862   0.000022     call s:build_sections(a:builder, a:context, s:layout[0])
                              else
                                let text = s:get_section(winnr, 'c')
                                if empty(text)
                                  let text = ' %f%m '
                                endif
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    2              0.000001   endif
                            
    2   0.000098   0.000024   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    2   0.000018   0.000013   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    2   0.000498   0.000016     call s:build_sections(a:builder, a:context, s:layout[1])
    2              0.000001   endif
                            
    2              0.000002   return 1

FUNCTION  neomake#utils#get_verbosity()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/neomake/autoload/neomake/utils.vim line 5
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000004     if a:0 && has_key(a:1, 'make_id')
                                    return neomake#GetMakeOptions(a:1.make_id).verbosity
    1              0.000001     endif
    1              0.000004     return get(g:, 'neomake_verbose', 1) + &verbose

FUNCTION  airline#util#wrap()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/util.vim line 36
Called 70 times
Total time:   0.000545
 Self time:   0.000545

count  total (s)   self (s)
   70              0.000252   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
   70              0.000049   endif
   70              0.000111   return a:text

FUNCTION  airline#load_theme()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline.vim line 39
Called 1 time
Total time:   0.035916
 Self time:   0.000102

count  total (s)   self (s)
    1              0.000008   let g:airline_theme = get(g:, 'airline_theme', 'dark')
    1              0.000011   if exists('*airline#themes#{g:airline_theme}#refresh')
                                call airline#themes#{g:airline_theme}#refresh()
    1              0.000001   endif
                            
    1              0.000007   let palette = g:airline#themes#{g:airline_theme}#palette
    1   0.000481   0.000015   call airline#themes#patch(palette)
                            
    1              0.000005   if exists('g:airline_theme_patch_func')
                                let Fn = function(g:airline_theme_patch_func)
                                call Fn(palette)
    1              0.000001   endif
                            
    1   0.028300   0.000017   call airline#highlighter#load_theme()
    1   0.000035   0.000013   call airline#extensions#load_theme()
    1   0.007050   0.000008   call airline#update_statusline()

FUNCTION  xolox#misc#cursorhold#autocmd()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-misc/autoload/xolox/misc/cursorhold.vim line 48
Called 1 time
Total time:   0.000176
 Self time:   0.000140

count  total (s)   self (s)
                              " The 'top level event handler' that's called by Vim whenever the
                              " [CursorHold][] or [CursorHoldI][] event fires. It iterates through the
                              " event handlers registered using `xolox#misc#cursorhold#register()` and
                              " calls each event handler at the appropriate interval, keeping track of
                              " the time when each event handler was last run.
    2              0.000008   for handler in g:xolox#misc#cursorhold#handlers
    1              0.000005     let function = handler['function']
    1              0.000006     let last_run = get(handler, 'last_run', 0)
    1              0.000004     let interval = get(handler, 'interval', 4)
    1   0.000044   0.000023     call xolox#misc#msg#debug("vim-misc %s: Checking handler %s with interval %i and last run %i ..", g:xolox#misc#version, function, interval, last_run)
                                " Rate limit in case &updatetime is set (very) low.
    1              0.000007     let time_until_next_run = (last_run + interval) - localtime()
    1              0.000003     if time_until_next_run > 0
    1   0.000032   0.000018       call xolox#misc#msg#debug("vim-misc %s: Rate limiting handler %s (time until next run: %i seconds).", g:xolox#misc#version, function, time_until_next_run)
                                else
                                  call xolox#misc#msg#debug("vim-misc %s: Running handler %s ..", g:xolox#misc#version, function)
                                  call call(function, get(handler, 'arguments', []))
                                  let handler['last_run'] = localtime()
    1              0.000001     endif
    2              0.000004   endfor

FUNCTION  airline#util#getwinvar()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/util.vim line 65
Called 24 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
   24              0.000072     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 57
Called 14 times
Total time:   0.003715
 Self time:   0.002641

count  total (s)   self (s)
   14              0.000074   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   14              0.000132   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
   14              0.000009   endif
   14              0.000164   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
   14              0.000063   if !exists('b:airline_whitespace_check')
    1              0.000004     let b:airline_whitespace_check = ''
    1              0.000010     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    1              0.000002     let trailing = 0
    1              0.000002     let check = 'trailing'
    1              0.000018     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1              0.000002       try
    1              0.000006         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    1              0.000125         let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
    1              0.000002       endtry
    1              0.000001     endif
                            
    1              0.000002     let mixed = 0
    1              0.000002     let check = 'indent'
    1              0.000014     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.000269   0.000018       let mixed = s:check_mixed_indent()
    1              0.000001     endif
                            
    1              0.000003     let mixed_file = ''
    1              0.000003     let check = 'mixed-indent-file'
    1              0.000015     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.000095   0.000020       let mixed_file = s:check_mixed_indent_file()
    1              0.000001     endif
                            
    1              0.000002     let long = 0
    1              0.000005     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
    1              0.000001     endif
                            
    1              0.000003     let conflicts = 0
    1              0.000004     if index(checks, 'conflicts') > -1
    1   0.000105   0.000016       let conflicts = s:conflict_marker()
    1              0.000001     endif
                            
    1              0.000008     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
    1              0.000001     endif
   14              0.000010   endif
   14   0.000830   0.000171   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  195()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/nerdtree/lib/nerdtree/creator.vim line 38
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000004     return 'NERD_tree_'

FUNCTION  airline#themes#patch()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/themes.vim line 39
Called 1 time
Total time:   0.000466
 Self time:   0.000466

count  total (s)   self (s)
   14              0.000031   for mode in keys(a:palette)
   13              0.000027     if mode == 'accents'
    1              0.000002       continue
   12              0.000009     endif
   12              0.000058     if !has_key(a:palette[mode], 'airline_warning')
                                  let a:palette[mode]['airline_warning'] = [ '#000000', '#df5f00', 232, 166 ]
   12              0.000008     endif
   12              0.000051     if !has_key(a:palette[mode], 'airline_error')
                                  let a:palette[mode]['airline_error'] = [ '#000000', '#990000', 232, 160 ]
   12              0.000008     endif
   12              0.000049     if !has_key(a:palette[mode], 'airline_term')
                                  let a:palette[mode]['airline_term'] = [ '#9cffd3', '#202020', 85, 232]
   12              0.000008     endif
   13              0.000012   endfor
                            
    1              0.000007   let a:palette.accents = get(a:palette, 'accents', {})
    1              0.000006   let a:palette.accents.none = [ '', '', '', '', '' ]
    1              0.000005   let a:palette.accents.bold = [ '', '', '', '', 'bold' ]
    1              0.000005   let a:palette.accents.italic = [ '', '', '', '', 'italic' ]
                            
    1              0.000004   if !has_key(a:palette.accents, 'red')
                                let a:palette.accents.red = [ '#ff0000' , '' , 160 , '' ]
    1              0.000001   endif
    1              0.000003   if !has_key(a:palette.accents, 'green')
                                let a:palette.accents.green = [ '#008700' , '' , 22  , '' ]
    1              0.000001   endif
    1              0.000003   if !has_key(a:palette.accents, 'blue')
                                let a:palette.accents.blue = [ '#005fff' , '' , 27  , '' ]
    1              0.000001   endif
    1              0.000003   if !has_key(a:palette.accents, 'yellow')
                                let a:palette.accents.yellow = [ '#dfff00' , '' , 190 , '' ]
    1              0.000001   endif
    1              0.000003   if !has_key(a:palette.accents, 'orange')
                                let a:palette.accents.orange = [ '#df5f00' , '' , 166 , '' ]
    1              0.000001   endif
    1              0.000003   if !has_key(a:palette.accents, 'purple')
                                let a:palette.accents.purple = [ '#af00df' , '' , 128 , '' ]
    1              0.000001   endif

FUNCTION  <SNR>239_build_sections()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/default.vim line 35
Called 4 times
Total time:   0.001323
 Self time:   0.000221

count  total (s)   self (s)
   18              0.000023   for key in a:keys
   14              0.000035     if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
   14              0.000006     endif
   14   0.001211   0.000109     call s:add_section(a:builder, a:context, key)
   18              0.000012   endfor

FUNCTION  <SNR>151_on_window_changed()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/plugin/airline.vim line 48
Called 1 time
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
    1              0.000011   let s:active_winnr = winnr()
                            
    1              0.000005   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
    1              0.000001   endif
                              " work around a neovim bug: do not trigger on floating windows
                              " Disabled, Bug is fixed in Neovim, TODO: should be removed soon
                              " if exists("*nvim_win_get_config") && !empty(nvim_win_get_config(0).relative)
                              "  return
                              " endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    1              0.000018   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
    1              0.000037   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    1              0.000002     return
                              endif
                              let g:airline_last_window_changed = l:key
                              call s:init()
                              call airline#update_statusline()

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline.vim line 156
Called 2 times
Total time:   0.000061
 Self time:   0.000056

count  total (s)   self (s)
    2   0.000021   0.000015   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
    2              0.000001   endif
    2              0.000004   for nr in a:range
                                if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
                                endif
                                call s:invoke_funcrefs(context, s:inactive_funcrefs)
    2              0.000003   endfor

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/builder.vim line 37
Called 16 times
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
   16              0.000030   let x = a:i - 1
   18              0.000022   while x >= 0
   16              0.000034     let group = a:sections[x][0]
   16              0.000031     if group != '' && group != '|'
   14              0.000014       return group
    2              0.000001     endif
    2              0.000002     let x = x - 1
    4              0.000003   endwhile
    2              0.000002   return ''

FUNCTION  neomake#VimLeave()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/neomake/autoload/neomake.vim line 1602
Called 1 time
Total time:   0.000077
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000067   0.000011     call neomake#log#debug('Calling VimLeave.')
    1              0.000005     for make_id in keys(s:make_info)
                                    call neomake#CancelMake(make_id)
    1              0.000001     endfor

FUNCTION  <SNR>218_cursormoved_delayed_cb()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/neomake/autoload/neomake.vim line 2507
Called 1 time
Total time:   0.000362
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000018     if getpos('.') == s:cursormoved_last_pos
    1   0.000340   0.000017         call neomake#CursorMoved()
    1              0.000001     endif

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/highlighter.vim line 243
Called 7 times
Total time:   0.071856
 Self time:   0.014617

count  total (s)   self (s)
    7              0.000029   let bufnr = a:0 ? a:1 : ''
    7              0.000040   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    7              0.000085   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    7              0.000028   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    7              0.000020   let airline_grouplist = []
    7              0.000040   let buffers_in_tabpage = sort(tabpagebuflist())
    7              0.000026   if exists("*uniq")
    7              0.000028     let buffers_in_tabpage = uniq(buffers_in_tabpage)
    7              0.000006   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
   14              0.000041   for mode in reverse(mapped)
    7              0.000056     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    5              0.000025       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
   80              0.000209       for kvp in items(dict)
   75              0.000194         let mode_colors = kvp[1]
   75              0.000164         let name = kvp[0]
   75              0.000303         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
   75              0.000053         endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
   75              0.000661         if name =~# 'airline_c\d\+'
                                      let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
                                      if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
                                      endif
   75              0.000545         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
   30              0.000038           continue
   45              0.000029         endif
   45   0.001046   0.000559         if s:group_not_done(airline_grouplist, name.suffix)
   45   0.014298   0.000589           call airline#highlighter#exec(name.suffix, mode_colors)
   45              0.000037         endif
                            
  135              0.000387         for accent in keys(s:accents)
   90              0.000338           if !has_key(p.accents, accent)
                                        continue
   90              0.000061           endif
   90              0.000436           let colors = copy(mode_colors)
   90              0.000314           if p.accents[accent][0] != ''
   45              0.000165             let colors[0] = p.accents[accent][0]
   90              0.000064           endif
   90              0.000247           if p.accents[accent][2] != ''
   45              0.000140             let colors[2] = p.accents[accent][2]
   90              0.000055           endif
   90              0.000229           if len(colors) >= 5
   90              0.000429             let colors[4] = get(p.accents[accent], 4, '')
                                      else
                                        call add(colors, get(p.accents[accent], 4, ''))
   90              0.000060           endif
   90   0.002223   0.001273           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
   90   0.028336   0.001268             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
   90              0.000069           endif
  135              0.000151         endfor
   50              0.000044       endfor
                            
    5              0.000014       if empty(s:separators)
                                    " nothing to be done
                                    continue
    5              0.000003       endif
                                  " TODO: optimize this
   35              0.000094       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
   30   0.015431   0.000407         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   35              0.000028       endfor
    7              0.000005     endif
   14              0.000026   endfor

FUNCTION  airline#parts#ffenc()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/parts.vim line 108
Called 2 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    2              0.000006   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
    2              0.000006   let bomb     = &l:bomb ? '[BOM]' : ''
    2              0.000022   let ff       = strlen(&ff) ? '['.&ff.']' : ''
    2              0.000011   if expected is# &fenc.bomb.ff
                                return ''
    2              0.000001   else
    2              0.000007     return &fenc.bomb.ff
                              endif

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/util.vim line 110
Called 14 times
Total time:   0.000503
 Self time:   0.000503

count  total (s)   self (s)
   14              0.000156   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  'gundo|undotree|vimfiler|tagbar|nerd_tree|startify|!')
   14              0.000327   return match(a:name, pat) > -1

FUNCTION  neomake#CursorMovedDelayed()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/neomake/autoload/neomake.vim line 2512
Called 1 time
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000007     if exists('s:cursormoved_timer')
    1              0.000003         call timer_stop(s:cursormoved_timer)
    1              0.000001     endif
    1              0.000005     let delay = get(g:, 'neomake_cursormoved_delay', 100)
    1              0.000011     let s:cursormoved_timer = timer_start(delay, function('s:cursormoved_delayed_cb'))
    1              0.000004     let s:cursormoved_last_pos = getpos('.')

FUNCTION  <SNR>241_can_diffoff()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-fugitive/autoload/fugitive.vim line 3510
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000020   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(s:Dir(a:buf)) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  neomake#log#debug()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/neomake/autoload/neomake/log.vim line 138
Called 1 time
Total time:   0.000056
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000055   0.000015     call call('s:log', [3] + a:000)

FUNCTION  WebDevIconsGetFileTypeSymbol()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-devicons/plugin/webdevicons.vim line 430
Called 14 times
Total time:   0.003905
 Self time:   0.003679

count  total (s)   self (s)
   14              0.000027   if a:0 == 0
   14              0.000071     let fileNodeExtension = expand('%:e')
   14              0.000051     let fileNode = expand('%:t')
   14              0.000028     let isDirectory = 0
                              else
                                let fileNodeExtension = fnamemodify(a:1, ':e')
                                let fileNode = fnamemodify(a:1, ':t')
                                if a:0 > 1
                                  let isDirectory = a:2
                                else
                                  let isDirectory = 0
                                endif
   14              0.000010   endif
                            
   14              0.000041   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                            
   14              0.000048     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
   14              0.000064     let fileNodeExtension = tolower(fileNodeExtension)
   14              0.000051     let fileNode = tolower(fileNode)
                            
  140              0.000438     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
  126              0.001203       if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
  126              0.000075       endif
  140              0.000112     endfor
                            
   14              0.000059     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
   14              0.000072       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
                                    let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
   14              0.000119       elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
   14              0.000066         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
                                  elseif isDirectory == 1
                                    let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
   14              0.000011       endif
   14              0.000011     endif
                            
                              else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
   14              0.000010   endif
                            
   14   0.000458   0.000233   let artifactFix = s:DevIconsGetArtifactFix()
                            
   14              0.000041   return symbol . artifactFix
                            

FUNCTION  airline#update_tabline()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline.vim line 273
Called 7 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    7              0.000026   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
    7              0.000005   endif

FUNCTION  airline#parts#paste()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/parts.vim line 63
Called 14 times
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
   14              0.000059   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  airline#update_statusline()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline.vim line 127
Called 2 times
Total time:   0.013892
 Self time:   0.000129

count  total (s)   self (s)
    2   0.000024   0.000016   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
    2              0.000001   endif
    2              0.000013   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    2   0.000077   0.000016   call airline#update_statusline_inactive(range)
                            
    2              0.000005   unlet! w:airline_render_left w:airline_render_right
    2              0.000025   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    2              0.000003   let w:airline_active = 1
    2              0.000011   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    2   0.013724   0.000031   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  airline#update_statusline_focuslost()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline.vim line 146
Called 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000019   if get(g:, 'airline_focuslost_inactive', 0)
                                let bufnr=bufnr('%')
                                call airline#highlighter#highlight_modified_inactive(bufnr)
                                call airline#highlighter#highlight(['inactive'], bufnr)
                                call airline#update_statusline_inactive(range(1, winnr('$')))
    1              0.000003   endif

FUNCTION  <SNR>177_on_vimleavepre()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-startify/plugin/startify.vim line 52
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000009   if get(g:, 'startify_session_persistence') && exists('v:this_session') && filewritable(v:this_session)
                                call startify#session_write(fnameescape(v:this_session))
    1              0.000001   endif

FUNCTION  airline#parts#readonly()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/parts.vim line 89
Called 14 times
Total time:   0.000940
 Self time:   0.000437

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
   14   0.000732   0.000229   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
   14              0.000012   endif
   14              0.000055   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
   14              0.000012   else
   14              0.000044     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  neomake#statusline#LoclistCounts()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/neomake/autoload/neomake/statusline.vim line 107
Called 14 times
Total time:   0.000241
 Self time:   0.000241

count  total (s)   self (s)
   14              0.000088     let buf = a:0 ? a:1 : bufnr('%')
   14              0.000030     if buf is# 'all'
                                    return s:counts
   14              0.000011     endif
   14              0.000070     return get(s:counts, buf, {})

FUNCTION  <SNR>235_group_not_done()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/highlighter.vim line 25
Called 135 times
Total time:   0.001438
 Self time:   0.001438

count  total (s)   self (s)
  135              0.000603   if index(a:list, a:name) == -1
  135              0.000533     call add(a:list, a:name)
  135              0.000168     return 1
                              else
                                if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
                                endif
                                return 0
                              endif

FUNCTION  airline#highlighter#exec()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/highlighter.vim line 104
Called 182 times
Total time:   0.050963
 Self time:   0.014710

count  total (s)   self (s)
  182              0.000339   if pumvisible()
                                return
  182              0.000116   endif
  182              0.000379   let colors = a:colors
  182              0.000268   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  182              0.000110   endif
  182   0.030684   0.002241   let old_hi = airline#highlighter#get_highlight(a:group)
  182              0.000464   if len(colors) == 4
   42              0.000100     call add(colors, '')
  182              0.000115   endif
  182              0.000340   if g:airline_gui_mode ==# 'gui'
  182              0.000927     let new_hi = [colors[0], colors[1], '', '', colors[4]]
                              else
                                let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  182              0.000123   endif
  182   0.007200   0.001848   let colors = s:CheckDefined(colors)
  182   0.004567   0.002109   if old_hi != new_hi || !s:hl_group_exists(a:group)
                                let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
                                exe cmd
                                if has_key(s:hl_groups, a:group)
                                  let s:hl_groups[a:group] = colors
                                endif
  182              0.000105   endif

FUNCTION  MakeViewCheck()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/restore_view.vim/plugin/restore_view.vim line 38
Called 1 time
Total time:   0.000222
 Self time:   0.000222

count  total (s)   self (s)
    1              0.000011     if &l:diff | return 0 | endif
    1              0.000008     if &buftype != '' | return 0 | endif
    1              0.000016     if expand('%') =~ '\[.*\]' | return 0 | endif
    1              0.000118     if empty(glob(expand('%:p'))) | return 0 | endif
    1              0.000005     if &modifiable == 0 | return 0 | endif
    1              0.000014     if len($TEMP) && expand('%:p:h') == $TEMP | return 0 | endif
    1              0.000007     if len($TMP) && expand('%:p:h') == $TMP | return 0 | endif
                            
    1              0.000018     let file_name = expand('%:p')
    1              0.000007     for ifiles in g:skipview_files
                                    if file_name =~ ifiles
                                        return 0
                                    endif
    1              0.000002     endfor
                            
    1              0.000002     return 1

FUNCTION  <SNR>235_get_array()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/highlighter.vim line 56
Called 286 times
Total time:   0.003061
 Self time:   0.003061

count  total (s)   self (s)
  286              0.001197   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  286              0.001692   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  neomake#statusline#QflistCounts()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/neomake/autoload/neomake/statusline.vim line 115
Called 14 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
   14              0.000062     return get(s:counts, 'project', s:unknown_counts)

FUNCTION  neomake#get_nearest_error()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/neomake/autoload/neomake.vim line 2446
Called 2 times
Total time:   0.000137
 Self time:   0.000137

count  total (s)   self (s)
    2              0.000010     let buf = bufnr('%')
    2              0.000006     let ln = line('.')
    2              0.000005     let ln_errors = []
                            
    6              0.000019     for maker_type in ['file', 'project']
    4              0.000031         let buf_errors = get(s:current_errors[maker_type], buf, {})
    4              0.000021         let ln_errors += get(buf_errors, ln, [])
    6              0.000009     endfor
                            
    2              0.000007     if empty(ln_errors)
    2              0.000004         return {}
                                endif
                            
                                if len(ln_errors) > 1
                                    call sort(ln_errors, function('neomake#utils#sort_by_col'))
                                endif
                                return ln_errors[0]

FUNCTION  EnableRelativeNumber()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-line-number-fold/plugin/number.vim line 16
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000013 	set number
    1              0.000005 	set relativenumber

FUNCTION  neomake#EchoCurrentError()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/neomake/autoload/neomake.vim line 2479
Called 1 time
Total time:   0.000154
 Self time:   0.000055

count  total (s)   self (s)
    1              0.000007     if !get(g:, 'neomake_echo_current_error', 1)
                                    return
    1              0.000002     endif
                                " a:1 might be a timer from the VimResized event.
    1              0.000007     let force = a:0 ? a:1 : 0
                            
    1   0.000116   0.000016     let message = neomake#GetCurrentErrorMsg()
    1              0.000003     if empty(message)
    1              0.000005         if exists('s:neomake_last_echoed_error')
                                        echon ''
                                        unlet s:neomake_last_echoed_error
    1              0.000001         endif
    1              0.000001         return
                                endif
                                if !force && exists('s:neomake_last_echoed_error') && s:neomake_last_echoed_error == message
                                    return
                                endif
                                let s:neomake_last_echoed_error = message
                                call neomake#utils#WideMessage(message)

FUNCTION  airline#builder#new()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/builder.vim line 232
Called 2 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    2              0.000014   let builder = copy(s:prototype)
    2              0.000004   let builder._context = a:context
    2              0.000003   let builder._sections = []
                            
    2              0.000027   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    2              0.000003   return builder

FUNCTION  airline#check_mode()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline.vim line 199
Called 14 times
Total time:   0.049249
 Self time:   0.002985

count  total (s)   self (s)
   14              0.000068   if !has_key(s:contexts, a:winnr)
                                return ''
   14              0.000021   endif
   14              0.000073   let context = s:contexts[a:winnr]
                            
   14              0.000069   if get(w:, 'airline_active', 1)
   14              0.000067     let l:m = mode(1)
   14              0.000041     if l:m ==# "i"
                                  let l:mode = ['insert']
   14              0.000045     elseif l:m[0] ==# "i"
                                  let l:mode = ['insert']
   14              0.000026     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
   14              0.000027     elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
   14              0.000201     elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
   14              0.000024     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
   14              0.000025     elseif l:m[0] ==# "c"
    2              0.000010       let l:mode = ['commandline']
   12              0.000022     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
   12              0.000031     elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
   12              0.000011     else
   12              0.000041       let l:mode = ['normal']
   14              0.000013     endif
   14              0.000092     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
   14              0.000012     endif
   14              0.000127     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
   14              0.000046       let l:m = l:m[0]
   14              0.000012     endif
   14              0.000095     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
                              else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
   14              0.000013   endif
                            
   14              0.000072   if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
   14              0.000011   endif
                            
   14              0.000042   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
   14              0.000011   endif
                            
   14              0.000194   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
   14              0.000010   endif
                            
   14              0.000050   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
   14              0.000009   endif
                            
   14              0.000039   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
   14              0.000010   endif
                            
   14              0.000085   let mode_string = join(l:mode)
   14              0.000077   if get(w:, 'airline_lastmode', '') != mode_string
    5   0.002299   0.000124     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    5   0.043760   0.000106     call airline#highlighter#highlight(l:mode, context.bufnr)
    5   0.000508   0.000073     call airline#util#doautocmd('AirlineModeChanged')
    5              0.000015     let w:airline_lastmode = mode_string
   14              0.000009   endif
                            
   14              0.000021   return ''

FUNCTION  airline#util#doautocmd()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/util.vim line 133
Called 6 times
Total time:   0.000483
 Self time:   0.000165

count  total (s)   self (s)
    6   0.000479   0.000161   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  fugitive#ReloadStatus()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-fugitive/autoload/fugitive.vim line 2040
Called 1 time
Total time:   0.000233
 Self time:   0.000233

count  total (s)   self (s)
    1              0.000005   if exists('s:reloading_status')
                                return
    1              0.000001   endif
    1              0.000002   try
    1              0.000004     let s:reloading_status = 1
    1              0.000004     let mytab = tabpagenr()
    3              0.000018     for tab in [mytab] + range(1,tabpagenr('$'))
    4              0.000017       for winnr in range(1,tabpagewinnr(tab,'$'))
    2              0.000021         if getbufvar(tabpagebuflist(tab)[winnr-1],'fugitive_type') ==# 'index'
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        if !&modified
                                          exe s:ReloadStatus()
                                        endif
                                      finally
                                        if exists('restorewinnr')
                                          unlet restorewinnr
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
    2              0.000002         endif
    4              0.000005       endfor
    3              0.000004     endfor
    1              0.000002   finally
    1              0.000004     unlet! s:reloading_status
    1              0.000002   endtry

FUNCTION  airline#parts#spell()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/parts.vim line 67
Called 14 times
Total time:   0.000523
 Self time:   0.000523

count  total (s)   self (s)
   14              0.000226   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   14              0.000046   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
   14              0.000009   endif
   14              0.000016   return ''

FUNCTION  <SNR>241_CanAutoReloadStatus()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-fugitive/autoload/fugitive.vim line 2074
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000021   return get(g:, 'fugitive_autoreload_status', !has('win32'))

FUNCTION  <SNR>238_section_is_empty()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/builder.vim line 185
Called 16 times
Total time:   0.000196
 Self time:   0.000196

count  total (s)   self (s)
   16              0.000021   let start=1
                            
                              " do not check for inactive windows or the tabline
   16              0.000022   if a:self._context.active == 0
                                return 0
   16              0.000038   elseif get(a:self._context, 'tabline', 0)
                                return 0
   16              0.000007   endif
                            
                              " only check, if airline#skip_empty_sections == 1
   16              0.000037   if get(g:, 'airline_skip_empty_sections', 0) == 0
   16              0.000011     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  airline#parts#crypt()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/parts.vim line 59
Called 14 times
Total time:   0.000216
 Self time:   0.000216

count  total (s)   self (s)
   14              0.000206   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#load_theme()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions.vim line 123
Called 1 time
Total time:   0.000023
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000022   0.000013   call airline#util#exec_funcrefs(s:ext._theme_funcrefs, g:airline#themes#{g:airline_theme}#palette)

FUNCTION  <SNR>175_persist()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-obsession/plugin/obsession.vim line 69
Called 1 time
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
    1              0.000005   if exists('g:SessionLoad')
                                return ''
    1              0.000001   endif
    1              0.000005   let sessionoptions = &sessionoptions
    1              0.000004   if exists('g:this_obsession')
                                try
                                  set sessionoptions-=blank sessionoptions-=options sessionoptions+=tabpages
                                  execute 'mksession! '.fnameescape(g:this_obsession)
                                  let body = readfile(g:this_obsession)
                                  call insert(body, 'let g:this_session = v:this_session', -3)
                                  call insert(body, 'let g:this_obsession = v:this_session', -3)
                                  if type(get(g:, 'obsession_append')) == type([])
                                    for line in g:obsession_append
                                      call insert(body, line, -3)
                                    endfor
                                  endif
                                  call writefile(body, g:this_obsession)
                                  let g:this_session = g:this_obsession
                                  exe s:doautocmd_user('Obsession')
                                catch
                                  unlet g:this_obsession
                                  let &l:readonly = &l:readonly
                                  return 'echoerr '.string(v:exception)
                                finally
                                  let &sessionoptions = sessionoptions
                                endtry
    1              0.000001   endif
    1              0.000002   return ''

FUNCTION  airline#parts#mode()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/parts.vim line 55
Called 14 times
Total time:   0.000856
 Self time:   0.000227

count  total (s)   self (s)
   14   0.000844   0.000215   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim line 14
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000005   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
    2              0.000001   endif

FUNCTION  233()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/nerdtree/lib/nerdtree/nerdtree.vim line 146
Called 2 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    2              0.000013     if exists("t:NERDTreeBufName")
                                    return bufwinnr(t:NERDTreeBufName)
    2              0.000002     endif
                            
    2              0.000004     return -1

FUNCTION  234()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/nerdtree/lib/nerdtree/nerdtree.vim line 155
Called 2 times
Total time:   0.000114
 Self time:   0.000076

count  total (s)   self (s)
    2   0.000112   0.000073     return s:NERDTree.GetWinNum() != -1 || bufname('%') =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'

FUNCTION  UpdateNumberByMode()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-line-number-fold/plugin/number.vim line 35
Called 2 times
Total time:   0.000164
 Self time:   0.000123

count  total (s)   self (s)
    2              0.000007 	if (a:curr_mode==0)
                            		" Normal Mode
    1              0.000006 		let g:is_insert_mode=0
    1              0.000003 		let g:is_normal_mode=1
    1   0.000037   0.000016 		call EnableRelativeNumber()
    1              0.000003 	elseif (a:curr_mode==1)
                            		" Insert Mode
    1              0.000004 		let g:is_insert_mode=1
    1              0.000003 		let g:is_normal_mode=0
    1   0.000036   0.000015 		call DisableRelativeNumber()
    2              0.000003 	endif

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim line 85
Called 2 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    2              0.000015   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'org', 'rst', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    2              0.000005   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    2              0.000003   if did_filetype()
                            
                                " Select test based on type of "filetypes": new=list, old=string
                                if type(filetypes) == get(v:, 't_list', type([])) ? index(filetypes, &filetype) > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
    2              0.000001   endif
                            
    2              0.000004   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
    2              0.000001   endif

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/highlighter.vim line 220
Called 12 times
Total time:   0.005780
 Self time:   0.000196

count  total (s)   self (s)
   12              0.000065   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   12   0.005709   0.000126   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  neomake#CursorMoved()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/neomake/autoload/neomake.vim line 2502
Called 1 time
Total time:   0.000323
 Self time:   0.000034

count  total (s)   self (s)
    1   0.000168   0.000014     call neomake#EchoCurrentError()
    1   0.000153   0.000019     call neomake#virtualtext#handle_current_error()

FUNCTION  xolox#session#auto_unlock()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-session/autoload/xolox/session.vim line 526
Called 1 time
Total time:   0.001135
 Self time:   0.000060

count  total (s)   self (s)
                              " Automatically unlock all sessions when Vim quits. Normally called by the
                              " [VimLeavePre] [] automatic command event.
                              "
                              " [VimLeavePre]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimLeavePre
    1   0.001101   0.000025   if xolox#session#locking_enabled()
    1              0.000004     let i = 0
    1              0.000006     while i < len(s:lock_files)
                                  let lock_file = s:lock_files[i]
                                  if delete(lock_file) == 0
                                    call remove(s:lock_files, i)
                                  else
                                    let i += 1
                                  endif
    1              0.000002     endwhile
    1              0.000001   endif

FUNCTION  <SNR>238_get_accented_line()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/builder.vim line 166
Called 14 times
Total time:   0.000630
 Self time:   0.000630

count  total (s)   self (s)
   14              0.000021   if a:self._context.active
                                " active window
   14              0.000021     let contents = []
   14              0.000089     let content_parts = split(a:contents, '__accent')
   28              0.000042     for cpart in content_parts
   14              0.000101       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   14              0.000037       call add(contents, cpart)
   28              0.000022     endfor
   14              0.000049     let line = join(contents, a:group)
   14              0.000095     let line = substitute(line, '__restore__', a:group, 'g')
                              else
                                " inactive window
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
   14              0.000007   endif
   14              0.000014   return line

FUNCTION  <SNR>193_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim line 39
Called 1 time
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
                              " Remove any previous match.
    1              0.000003   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
    1              0.000000   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    1              0.000004   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
    1              0.000000   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    1              0.000002   let c_lnum = line('.')
    1              0.000002   let c_col = col('.')
    1              0.000001   let before = 0
                            
    1              0.000003   let text = getline(c_lnum)
    1              0.000017   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    1              0.000002   if empty(matches)
                                let [c_before, c] = ['', '']
    1              0.000001   else
    1              0.000005     let [c_before, c] = matches[1:2]
    1              0.000001   endif
    1              0.000012   let plist = split(&matchpairs, '.\zs[:,]')
    1              0.000003   let i = index(plist, c)
    1              0.000001   if i < 0
                                " not found, in Insert mode try character before the cursor
    1              0.000004     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
    1              0.000001     endif
    1              0.000001     if i < 0
                                  " not found, nothing to do
    1              0.000001       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  airline#statusline()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline.vim line 190
Called 14 times
Total time:   0.000363
 Self time:   0.000363

count  total (s)   self (s)
   14              0.000162   if has_key(s:contexts, a:winnr)
   14              0.000165     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>238_get_seperator()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/builder.vim line 158
Called 10 times
Total time:   0.007652
 Self time:   0.000207

count  total (s)   self (s)
   10   0.002454   0.000089   if airline#builder#should_change_group(a:prev_group, a:group)
   10   0.005192   0.000112     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  airline#highlighter#load_theme()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/highlighter.vim line 205
Called 1 time
Total time:   0.028283
 Self time:   0.000081

count  total (s)   self (s)
    1              0.000003   if pumvisible()
                                return
    1              0.000001   endif
    1              0.000015   for winnr in filter(range(1, winnr('$')), 'v:val != winnr()')
                                call airline#highlighter#highlight_modified_inactive(winbufnr(winnr))
    1              0.000002   endfor
    1   0.017377   0.000020   call airline#highlighter#highlight(['inactive'])
    1              0.000008   if getbufvar( bufnr('%'), '&modified'  )
                                call airline#highlighter#highlight(['normal', 'modified'])
    1              0.000001   else
    1   0.010863   0.000018     call airline#highlighter#highlight(['normal'])
    1              0.000001   endif

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/builder.vim line 130
Called 10 times
Total time:   0.002365
 Self time:   0.000272

count  total (s)   self (s)
   10              0.000021   if a:group1 == a:group2
                                return 0
   10              0.000005   endif
   10   0.001203   0.000095   let color1 = airline#highlighter#get_highlight(a:group1)
   10   0.001076   0.000090   let color2 = airline#highlighter#get_highlight(a:group2)
   10              0.000013   if g:airline_gui_mode ==# 'gui'
   10              0.000030     return color1[1] != color2[1] || color1[0] != color2[0]
                              else
                                return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  <SNR>135_echo()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-bufferline/autoload/bufferline.vim line 81
Called 1 time
Total time:   0.000509
 Self time:   0.000134

count  total (s)   self (s)
    1              0.000006   if &filetype ==# 'unite'
                                return
    1              0.000001   endif
                            
    1   0.000394   0.000018   let line = bufferline#get_echo_string()
                            
                              " 12 is magical and is the threshold for when it doesn't wrap text anymore
    1              0.000005   let width = &columns - 12
    1              0.000003   if g:bufferline_rotate == 2
                                let current_buffer_start = stridx(line, g:bufferline_active_buffer_left)
                                let current_buffer_end = stridx(line, g:bufferline_active_buffer_right)
                                if current_buffer_start < s:window_start
                                  let s:window_start = current_buffer_start
                                endif
                                if current_buffer_end > (s:window_start + width)
                                  let s:window_start = current_buffer_end - width + 1
                                endif
                                let line = strpart(line, s:window_start, width)
    1              0.000001   else
    1              0.000004     let line = strpart(line, 0, width)
    1              0.000001   endif
                            
    1              0.000054   echo line
                            
    1              0.000004   if &updatetime != s:updatetime
                                let &updatetime = s:updatetime
    1              0.000001   endif

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/highlighter.vim line 67
Called 286 times
Total time:   0.039931
 Self time:   0.019830

count  total (s)   self (s)
  286              0.004039   let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  286              0.001218   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
  286              0.000206   else
  286   0.011335   0.002453     let fg = s:get_syn(a:group, 'fg')
  286   0.010434   0.002277     let bg = s:get_syn(a:group, 'bg')
  286              0.001445     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  286              0.000352     if reverse
                                  let res = s:get_array(bg, fg, bold ? ['bold'] : a:000)
  286              0.000205     else
  286   0.005939   0.002878       let res = s:get_array(fg, bg, bold ? ['bold'] : a:000)
  286              0.000188     endif
  286              0.000161   endif
  286              0.001096   let s:hl_groups[a:group] = res
  286              0.000326   return res

FUNCTION  airline#util#shorten()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/util.vim line 22
Called 28 times
Total time:   0.001288
 Self time:   0.000883

count  total (s)   self (s)
   28   0.000863   0.000457   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return 'â€¦'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'â€¦'
                                endif
   28              0.000020   else
   28              0.000049     return a:text
                              endif

FUNCTION  xolox#misc#option#get()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-misc/autoload/xolox/misc/option.vim line 7
Called 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
                              " Expects one or two arguments: 1. The name of a variable and 2. the default
                              " value if the variable does not exist.
                              "
                              " Returns the value of the variable from a buffer local variable, global
                              " variable or the default value, depending on which is defined.
                              "
                              " This is used by some of my Vim plug-ins for option handling, so that users
                              " can customize options for specific buffers.
    1              0.000010   if exists('b:' . a:name)
                                " Buffer local variable.
                                return eval('b:' . a:name)
    1              0.000005   elseif exists('g:' . a:name)
                                " Global variable.
                                return eval('g:' . a:name)
    1              0.000004   elseif exists('a:1')
                                " Default value.
    1              0.000002     return a:1
                              endif

FUNCTION  <SNR>158_CursorHoldUpdate()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-devicons/plugin/webdevicons.vim line 336
Called 1 time
Total time:   0.000070
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000003   if g:NERDTreeUpdateOnCursorHold != 1
                                return
    1              0.000001   endif
                            
    1   0.000060   0.000016   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
    1              0.000001     return
                              endif
                            
                              " Do not update when a special buffer is selected
                              if !empty(&l:buftype)
                                return
                              endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
                              let l:winnr = winnr()
                              let l:altwinnr = winnr('#')
                            
                              call g:NERDTree.CursorToTreeWin()
                              call b:NERDTree.root.refreshFlags()
                              call NERDTreeRender()
                            
                              exec l:altwinnr . 'wincmd w'
                              exec l:winnr . 'wincmd w'

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/highlighter.vim line 229
Called 5 times
Total time:   0.002175
 Self time:   0.000295

count  total (s)   self (s)
    5              0.000034   if getbufvar(a:bufnr, '&modified')
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    5              0.000005   else
    5              0.000081     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    5              0.000005   endif
                            
    5              0.000015   if !empty(colors)
    5   0.001979   0.000099     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    5              0.000004   endif

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/keymap.vim line 10
Called 14 times
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
   14              0.000121   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   14              0.000109     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  <SNR>151_on_cursor_moved()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/plugin/airline.vim line 74
Called 1 time
Total time:   0.000020
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000003   if winnr() != s:active_winnr
                                call s:on_window_changed('CursorMoved')
    1              0.000001   endif
    1   0.000013   0.000007   call airline#update_tabline()

FUNCTION  <SNR>159_invoke_funcrefs()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline.vim line 177
Called 2 times
Total time:   0.013693
 Self time:   0.000106

count  total (s)   self (s)
    2   0.000068   0.000014   let builder = airline#builder#new(a:context)
    2   0.002346   0.000030   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    2              0.000002   if err == 1
    2   0.011237   0.000020     let a:context.line = builder.build()
    2              0.000010     let s:contexts[a:context.winnr] = a:context
    2              0.000007     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
    2              0.000019     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
    2              0.000001   endif

FUNCTION  <SNR>219_is_excluded_window()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions.vim line 103
Called 2 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    2              0.000005   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
    2              0.000002   endfor
                            
    8              0.000009   for matchw in g:airline_exclude_filenames
    6              0.000037     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
    6              0.000002     endif
    8              0.000004   endfor
                            
    2              0.000003   if g:airline_exclude_preview && &previewwindow
                                return 1
    2              0.000001   endif
                            
    2              0.000002   return 0

FUNCTION  <SNR>239_get_section()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/default.vim line 20
Called 18 times
Total time:   0.000722
 Self time:   0.000573

count  total (s)   self (s)
   18              0.000045   if has_key(s:section_truncate_width, a:key)
   12   0.000180   0.000084     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
    2              0.000002       return ''
   10              0.000005     endif
   16              0.000007   endif
   16              0.000026   let spc = g:airline_symbols.space
   16              0.000061   if !exists('g:airline_section_{a:key}')
                                return ''
   16              0.000007   endif
   16   0.000190   0.000137   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   16              0.000091   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   16              0.000052   return empty(text) ? '' : prefix.text.suffix

FUNCTION  airline#extensions#po#apply()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/po.vim line 45
Called 2 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    2              0.000008   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
    2              0.000001   endif

FUNCTION  airline#highlighter#reset_hlcache()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/highlighter.vim line 63
Called 1 time
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
    1              0.000121   let s:hl_groups = {}

FUNCTION  airline#util#prepend()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/util.vim line 57
Called 56 times
Total time:   0.000552
 Self time:   0.000552

count  total (s)   self (s)
   56              0.000191   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
   56              0.000037   endif
   56              0.000225   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>158_DevIconsGetArtifactFix()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-devicons/plugin/webdevicons.vim line 481
Called 14 times
Total time:   0.000226
 Self time:   0.000226

count  total (s)   self (s)
   14              0.000036   if g:DevIconsAppendArtifactFix == 1
                                let artifactFix = g:DevIconsArtifactFixChar
   14              0.000011   else
   14              0.000031     let artifactFix = ''
   14              0.000012   endif
                            
   14              0.000084   return artifactFix

FUNCTION  <SNR>227_get_counts()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/autoload/airline/extensions/neomake.vim line 11
Called 14 times
Total time:   0.000705
 Self time:   0.000394

count  total (s)   self (s)
   14   0.000414   0.000173   let l:counts = neomake#statusline#LoclistCounts()
                            
   14              0.000036   if empty(l:counts)
   14   0.000228   0.000158     return neomake#statusline#QflistCounts()
                              else
                                return l:counts
                              endif

FUNCTION  <SNR>151_airline_refresh()
    Defined: ~/.dotfile/nvim/.local/share/nvim/plugged/vim-airline/plugin/airline.vim line 206
Called 1 time
Total time:   0.043076
 Self time:   0.000135

count  total (s)   self (s)
                              " a:1, fast refresh, do not reload the theme
    1              0.000009   let fast=!empty(get(a:000, 0, 0))
    1              0.000008   if !exists("#airline")
                                " disabled
                                return
    1              0.000001   endif
    1   0.000062   0.000014   call airline#util#doautocmd('AirlineBeforeRefresh')
    1   0.000145   0.000022   call airline#highlighter#reset_hlcache()
    1              0.000003   if !fast
    1   0.035965   0.000050     call airline#load_theme()
    1              0.000000   endif
    1   0.006860   0.000011   call airline#update_statusline()
    1   0.000016   0.000010   call airline#update_tabline()

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    7   0.071856   0.014617  airline#highlighter#highlight()
  182   0.050963   0.014710  airline#highlighter#exec()
   14   0.049249   0.002985  airline#check_mode()
    1   0.043076   0.000135  <SNR>151_airline_refresh()
  286   0.039931   0.019830  airline#highlighter#get_highlight()
    1   0.035916   0.000102  airline#load_theme()
    1   0.028283   0.000081  airline#highlighter#load_theme()
   42   0.020607   0.001963  <SNR>235_exec_separator()
  572   0.017040             <SNR>235_get_syn()
    2   0.013892   0.000129  airline#update_statusline()
    2   0.013693   0.000106  <SNR>159_invoke_funcrefs()
    2   0.011217   0.001466  307()
   84   0.010338   0.000943  airline#themes#get_highlight()
   10   0.007652   0.000207  <SNR>238_get_seperator()
   12   0.006186   0.000406  <SNR>238_get_transitioned_seperator()
   12   0.005780   0.000196  airline#highlighter#add_separator()
  182   0.005351             <SNR>235_CheckDefined()
   14   0.004286   0.000404  bufferline#refresh_status()
   15   0.004257   0.001110  bufferline#get_echo_string()
   14   0.003905   0.003679  WebDevIconsGetFileTypeSymbol()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  286   0.039931   0.019830  airline#highlighter#get_highlight()
  572              0.017040  <SNR>235_get_syn()
  182   0.050963   0.014710  airline#highlighter#exec()
    7   0.071856   0.014617  airline#highlighter#highlight()
  182              0.005351  <SNR>235_CheckDefined()
   14   0.003905   0.003679  WebDevIconsGetFileTypeSymbol()
   15              0.003147  <SNR>135_generate_names()
  286              0.003061  <SNR>235_get_array()
   14   0.049249   0.002985  airline#check_mode()
   14   0.003715   0.002641  airline#extensions#whitespace#check()
  182              0.002458  <SNR>235_hl_group_exists()
   42   0.020607   0.001963  <SNR>235_exec_separator()
    2   0.011217   0.001466  307()
  135              0.001438  <SNR>235_group_not_done()
   98              0.001371  airline#util#append()
   15   0.004257   0.001110  bufferline#get_echo_string()
   84   0.010338   0.000943  airline#themes#get_highlight()
   28   0.001288   0.000883  airline#util#shorten()
    1   0.001076   0.000773  xolox#session#locking_enabled()
   54              0.000691  airline#util#winwidth()

